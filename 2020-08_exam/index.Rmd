---
title: "Improving the prediction of bus arrival using real-time network state"
author: "<br><br>Tom Elliott"
date: "25 August 2020"
output:
    revealjs::revealjs_presentation:
        theme: serif
        center: false
        slide_level: 1
        mathjax: default
        reveal_options:
            controls: false
            hash: true
        transition: none
bibliography: reflist.bib
csl: apa.csl
---


# Part I
```{sass, echo=FALSE}
$col1: #18afe3
$col2: #094b85
.reveal
    pre
        margin-top: 5px
        margin-bottom: 5px

    section
        text-align: left
        strong
            color: $col1

        /*ul>li>span
            color: $col1*/

        ul>li>ul
            font-size: 0.6em
            list-style-type: '&ndash; '

        #refs
            font-size: 0.3em
/***/
```

### What is the status quo, and what is wrong with it?

***
## In Auckland ...

* real-time vehicle locations
* arrival and departure times/delays <br><br>
* ETA = scheduled arrival + current delay
* *no use of location information, traffic, historical, ...*


***
## Around the world ...

* many unique real-time information systems
* various data feeds:
    * *vehicle positions, passenger counters, taxis, ...*
* equally different prediction systems
    * *Kalman filter, artificial neural network, support vector machines, ...*
  <br><br>
* GTFS: *General Transit Feed Specification*


***
## Vehicle models

* operations management
    * *on-time performance, reducing bunching behaviour, ...*
* little recent focus on ETAs
    * Kalman filter (e.g., @Dailey_2001, @Cathey_2003)
    * ANN/SVM (e.g., @Yu_2006, ...)
* but lots of cool models
    * particle filtering (e.g., @Hans_2015)

***
## Traffic models

* essential for reliable predictions
* difficult to model (data availability, ...)
* location-specific examples
    * @Yu_2011 *previous bus along same road, different route*
    * @Julio_2016 *traffic shockwaves*
    * ... *taxi data*<br><br>
* vast majority of transit feeds use *only* GTFS

***
## Arrival time prediction & journey planning

* current position, travel times, dwell times
* GTFS default: *schedule + current delay*
* usually a point estimate "*ETA: 5 mins*"<br><br>
* JP is hard (@Horn_2004, @Hame_2013a)
* Simple to complex questions
    * which bus to arrive on time
    * which set of buses to get to destination fastest
    * minimal waiting time between legs
* @Berczi_2017: use of probabilitic arrival time information


# Part II

### Bus arrival prediction using real-time network state

<br><br>

1. GTFS network construction
2. Vehicle model
3. Transit network model
4. Arrival time prediction
5. Journey planning


***
## 1. GTFS network construction

```{r,eval=F}
library(transitr)
nw <- create_gtfs("https://cdn01.at.govt.nz/data/gtfs.zip",
    db = "at_gtfs.sqlite")
nw %>% construct()
```

```{r, echo=F, fig.width=10,fig.height=4,message=FALSE,warning=FALSE}
library(RSQLite)
library(dplyr)
library(dbplyr)
library(magrittr)
con <- dbConnect(SQLite(), 'at_gtfs.sqlite')
routes <- con %>% tbl('routes') %>%
    filter(
        route_short_name %in% c('27W', '24R', '22A') &
        (route_long_name %like% '%To City%' | route_long_name %like% '%To Britomart%') &
        version == 94.7
    ) %>% select(route_id, route_short_name, route_long_name) %>% collect()
trips <- con %>% tbl('trips') %>%
    filter(
        route_id %in% !!routes$route_id
    ) %>%
    select(route_id, trip_id, shape_id) %>%
    group_by(route_id) %>%
    summarize(trip_id = min(trip_id, na.rm = TRUE), shape_id = min(shape_id, na.rm = TRUE)) %>%
    collect() %>%
    left_join(routes, by = 'route_id')
shapes <- con %>% tbl('shapes') %>%
    filter(shape_id %in% !!trips$shape_id) %>%
    select(shape_id, shape_pt_lat, shape_pt_lon, shape_pt_sequence) %>%
    collect() %>%
    left_join(trips, by = 'shape_id') %>%
    filter(
        shape_pt_lat > -36.875 &
        shape_pt_lon > 174.74
    )
stops <- con %>% tbl('stop_times') %>%
    filter(
        trip_id %in% !!trips$trip_id
    ) %>%
    left_join(con %>% tbl('stops'), by = 'stop_id') %>%
    select(stop_code, trip_id, stop_sequence, stop_lat, stop_lon) %>%
    collect() %>%
    left_join(trips, by = 'trip_id') %>%
    filter(
        stop_lat > -36.875 &
        stop_lon > 174.74
    ) %>%
    arrange(route_short_name, stop_sequence)
stops2 <- stops %>%
    mutate(
        stop_lat = ifelse(stop_code %in% c('8213', '8211'), stop_lat + 0.0015, stop_lat)
    )

dbDisconnect(con)

library(ggplot2)
pp <- ggplot(shapes, aes(shape_pt_lon, shape_pt_lat, colour = route_short_name)) +
    coord_fixed(ratio = 1/0.8) +
    theme_void() +
    theme(legend.position = "bottom") +
    labs(colour = "")

pp + facet_grid(~route_short_name) +
    geom_path(lwd = 2)
    # geom_point(aes(stop_lon, stop_lat), data = stops)
```


***
## 1. GTFS network construction

```{r,eval=F}
library(transitr)
nw <- create_gtfs("https://cdn01.at.govt.nz/data/gtfs.zip",
    db = "at_gtfs.sqlite")
nw %>% construct()
```

```{r, echo=F, fig.width=10,fig.height=4,message=FALSE,warning=FALSE}
pp +
    geom_path(lwd = 2) +
    geom_path(aes(linetype = route_short_name), lwd = 2) +
    geom_point(aes(stop_lon, stop_lat, colour = NULL), data = stops) +
    labs(linetype = "")
```


***
## 1. GTFS network construction

```{r,eval=F}
library(transitr)
nw <- create_gtfs("https://cdn01.at.govt.nz/data/gtfs.zip",
    db = "at_gtfs.sqlite")
nw %>% construct()
```

```{r, echo=F, fig.width=10,fig.height=4,message=FALSE,warning=FALSE}
pp +
    geom_path(aes(stop_lon, stop_lat), lwd = 2, data = stops2) +
    geom_path(aes(stop_lon, stop_lat, linetype = route_short_name), lwd = 2, data = stops2) +
    geom_point(aes(stop_lon, stop_lat, colour = NULL), data = stops2) +
    labs(linetype = "")
```

***
## 2. Vehicle model

* Observations $\boldsymbol{y}_1, \boldsymbol{y}_2, \cdots, \boldsymbol{y}_{k-1}, \boldsymbol{y}_k$
* Underlying state $\boldsymbol{x}_0, \boldsymbol{x}_1, \cdots, \boldsymbol{x}_{k-2}, \boldsymbol{x}_k$<br><br>
* Recursive Bayesian estimation: **Predict** and **Update**
* Estimates distance, speed,
  *average speed along each road segment*

***
## 3. Transit network model

* Observations $b_{v\ell c}$ with error $e_{v\ell c}$
    * average speed of vehicle $v$, road $\ell$, time period $(t_{c-1},t_c]$
* Underlying state $\beta_{\ell c}$ (average vehicle speed, m/s)<br><br>
* Hierarchical structure
\[
    \begin{split}
    b_{v\ell c} &\sim \mathcal{N}(B_{v\ell c}, e_{v\ell c}^2) \\
    B_{v\ell c} &\sim \mathcal{N}_T(\beta_{\ell c}, \phi_\ell^2) \\
    \beta_{\ell c} &\sim \mathcal{N}_T(F_c(\beta_{\ell,c-1}, \Delta_c), q^2),\quad
        \Delta_c = t_c - t_{c-1}
    \end{split}
\]

***
## 3. Transit network model

* Historical data to estimate $\phi_\ell$ and $q$
* JAGS [@JAGS]<br><br>
* Kalman filter: real-time network state
    * $\hat \beta_{c|c-1} = \mathbb{E}(\beta_c | b_{0:c-1})$
    * $P_{c|c-1} = \mathrm{Var}(\beta_c | b_{0:c-1})$
* Information filter
    * Multiple vehicles/segment/time period
    * Limited to independent segments

***
## 3. Transit network model: results

[[ A picture of travel times with JAGS and KF fits overlaid ]]


***
## 4. Arrival time prediction

* ETA = travel time + dwell time
    * @Shalaby_2004, @Jeong_2005, @Hans_2015
* Travel times: sum of (distributions) of segment travel times
    * travel time = distance / speed
* Dwell times: multimodality (dwell can be zero)

***
## 4. Arrival time prediction

* Particle filter
    * particles complete route recording arrival times
    * handles dwell time, layovers, etc.
```{r,echo=FALSE,fig.width=8,fig.height=3,message=FALSE}
set.seed(324456)
x <- data.frame(x = c(rnorm(1000, 5.2*60, 20), rnorm(1000, 6.3*60, 30)))
p_dist <- ggplot(x, aes(x/60, ..count../sum(..count..))) +
    geom_histogram() +
    theme_classic() +
    xlab("ETA (minutes)") + ylab("Probability")
p_dist
```

***
## 5. Journey planning

* Need a useful summary of $p(\alpha_j|\mathcal{T}_k, \boldsymbol{\beta}_k)$
* ETAs expected as integer minutes
* CDF approximation
\[
    \mathbb{P}(A < a) = \sum_{x=0}^{x=a-1} \mathbb{P}(A \in [x, x+1))
    = \sum_{x=0}^{x=a-1} \left( \frac{1}{N^\star} \sum_{i=1}^{N^\star} I_{\lfloor \alpha^{(i)}/60 \rfloor = x} \right)
\]

***

```{r,echo=FALSE,fig.width=8,fig.height=6,message=FALSE,fig.align="center"}
x <- x %>% mutate(z = floor(x / 60))
cdf <- x %>% group_by(z) %>% summarize(n = length(z)) %>% mutate(p = n / sum(n)) %>%
    bind_rows(data.frame(z = min((.)$z) - 1, n = 0, p = 0)) %>%
    bind_rows(data.frame(z = max((.)$z) + 1, n = 0, p = 0)) %>%
    arrange(z) %>%
    mutate(p = cumsum(p))
p_cdf <- ggplot(cdf, aes(z, p)) +
    geom_step() +
    theme_classic() +
    xlab("ETA, a (minutes)") + ylab("P(A < a)")

library(patchwork)
p_dist / p_cdf
```

***
## 5. Journey planning

* CDF allows us to answer questions:
    * change of catching bus if I arrive at $a$
    * which bus should I catch to have at least 90% change of on-time arrival
    * probabilty of making transfer between two services
* Provides event probabilities (not binary 'Yes' or 'No')


# Part III

### Using particle filtering to model vehicles and generate arrival time distributions


***
## Why the particle filter?

* Flexible with few assumptions
* Handles complex vehicle behaviour
* Intuitive likelihood<br><br>
* Multimodality


***
## Why not the particle filter?

* Computationally intensive
* Hard to distribute the results

***
## Why not the particle filter?

* Computationally intensive
* ~~Hard to distribute the results~~

***
## Particle filter in action

```{r,echo=FALSE,message=FALSE,warning=FALSE,fig.width=10,fig.height=4}
con <- dbConnect(SQLite(), 'at_gtfs.sqlite')
routes <- con %>% tbl('routes') %>%
    filter(
        route_short_name == "380" &
        route_long_name %like% '%To Onehunga%' &
        version == 94.7
    ) %>% select(route_id, route_short_name, route_long_name) %>% collect()
trips <- con %>% tbl('trips') %>%
    filter(
        route_id %in% !!routes$route_id
    ) %>%
    select(route_id, trip_id, shape_id) %>%
    group_by(route_id) %>%
    summarize(trip_id = min(trip_id, na.rm = TRUE), shape_id = min(shape_id, na.rm = TRUE)) %>%
    collect() %>%
    left_join(routes, by = 'route_id')
shapes <- con %>% tbl('shapes') %>%
    filter(shape_id %in% !!trips$shape_id) %>%
    select(shape_id, shape_pt_lat, shape_pt_lon, shape_pt_sequence) %>%
    collect() %>%
    left_join(trips, by = 'shape_id') %>%
    filter(
        shape_pt_lon > 174.848 & shape_pt_lon < 174.86
    )
stops <- con %>% tbl('stop_times') %>%
    filter(
        trip_id %in% !!trips$trip_id
    ) %>%
    left_join(con %>% tbl('stops'), by = 'stop_id') %>%
    select(stop_code, trip_id, stop_sequence, stop_lat, stop_lon) %>%
    collect() %>%
    left_join(trips, by = 'trip_id') %>%
    arrange(route_short_name, stop_sequence)
dbDisconnect(con)

library(geosphere)
library(patchwork)
shapes <- shapes %>%
    mutate(
        dist = distGeo(cbind(shape_pt_lon, shape_pt_lat)),
        dist = c(0, cumsum(dist[!is.na(dist)]))
    )

proj <- function(x, path) {
    d <- path[,3]
    path <- path[, 1:2]
    if (x <= 0) return(path[1, ] %>% as.numeric)
    if (x >= max(d)) return(path[nrow(path), ] %>% as.numeric)
    i <- which(d > x)[1]
    # from i-1:i
    if (x == d[i]) return(path[i, ])
    p1 <- path[i, ] %>% as.numeric
    p2 <- path[i-1, ] %>% as.numeric
    b <- geosphere::bearing(p1, p2)
    h <- d[i] - x
    as.numeric(geosphere::destPoint(p1, b, h))
}
h <- function(state, path) {
    p <- sapply(state$x, proj, path = path)
    state %>% mutate(lon = p[1,], lat = p[2,])
}

set.seed(235216)
N <- 50
state <- tibble(x = rnorm(N, 500, 10), xdot = rnorm(N, 12, 3))
path <- cbind(shapes$shape_pt_lon, shapes$shape_pt_lat, shapes$dist)
state <- h(state, path)

ploop <- ggplot(shapes, aes(shape_pt_lon, shape_pt_lat)) +
    geom_path() +
    coord_fixed(ratio = 1/0.8) +
    theme_void() +
    theme(legend.position = "bottom") +
    labs(colour = "")
pdist <- ggplot(state, aes(x)) +
    theme_classic() +
    xlab("Distance (m)") + ylab("") + xlim(400, 1600) +
    theme(axis.text.y = element_blank())
pspeed <- ggplot(state, aes(xdot)) +
    theme_classic() +
    xlab("Speed (m/s)") + ylab("") + xlim(0, 25) +
    theme(axis.text.y = element_blank())

obs <- tibble(lon = mean(state$lon), lat = mean(state$lat) - 0.00005)

library(ggrepel)
p1 <- ploop +
    geom_point(aes(lon, lat), data = state) +
    geom_point(aes(lon, lat), data = obs, colour = "red", size = 2) +
    geom_text(aes(lon, lat, label = "Y[k-1]"), data = obs, nudge_y = -0.0005, parse = TRUE)
p2 <- pdist + geom_histogram()
p3 <- pspeed + geom_histogram()

p1 + (p2 / p3 + plot_layout(height = c(2, 1))) + plot_layout(width = c(2, 1))

```

\[
    p(\boldsymbol{x}_{k-1} | \boldsymbol{y}_{1:k-1}) \approx
    \sum_{i=1}^N w_{k-1}^{(i)} \delta_{\boldsymbol{x}_{k-1}^{(i)}} (\boldsymbol{x}_{k-1})
\]

<small>$N = `r N`$</small>

***
## Particle filter in action: predict

```{r,echo=FALSE,message=FALSE,warning=FALSE,fig.width=10,fig.height=4}
state <- state %>%
    mutate(t = 60 - rbinom(N, 1, 0.5) * (20 + rnorm(N, 10, 5))) %>%
    mutate(xdot = truncnorm::rtruncnorm(N, 3, 20, xdot, 1.5)) %>%
    mutate(x = pmax(650, x + t * xdot))
state <- h(state, path)


ploop <- ggplot(shapes, aes(shape_pt_lon, shape_pt_lat)) +
    geom_path() +
    coord_fixed(ratio = 1/0.8) +
    theme_void() +
    theme(legend.position = "bottom") +
    labs(colour = "")
pdist <- ggplot(state, aes(x)) +
    theme_classic() +
    xlab("Distance (m)") + ylab("") + xlim(400, 1600) +
    theme(axis.text.y = element_blank())
pspeed <- ggplot(state, aes(xdot)) +
    theme_classic() +
    xlab("Speed (m/s)") + ylab("") + xlim(0, 25) +
    theme(axis.text.y = element_blank())

p1 <- ploop +
    geom_point(aes(lon, lat), data = state)
    # geom_point(aes(lon, lat), data = obs, colour = "red", size = 2) +
    # geom_text(aes(lon, lat, label = "Y[k-1]"), data = obs, nudge_y = -0.0005, parse = TRUE)
p2 <- pdist + geom_histogram()
p3 <- pspeed + geom_histogram()

p1 + (p2 / p3 + plot_layout(height = c(2, 1))) + plot_layout(width = c(2, 1))

```

\[
    p(\boldsymbol{x}_{k} | \boldsymbol{x}_{k-1}) \approx
    \sum_{i=1}^N w_{k-1}^{(i)} \delta_{\boldsymbol{x}_{k}^{(i)}} (\boldsymbol{x}_{k})
\]

<small>$\boldsymbol{x}_k^{(i)} = f(\boldsymbol{x}_{k-1}^{(i)}, \Delta_k, \sigma^2)$, $\Delta_k = t_k - t_{k-1} = 60$</small>



***
## Particle filter in action: update

```{r,echo=FALSE,message=FALSE,warning=FALSE,fig.width=10,fig.height=4}
obs <- proj(750, path)
obs <- tibble(lon = obs[1], lat = obs[2] + 0.00005)

p1 <- ploop +
    geom_point(aes(lon, lat), data = state) +
    geom_point(aes(lon, lat), data = obs, colour = "red", size = 2) +
    geom_text(aes(lon, lat, label = "Y[k]"), data = obs, nudge_y = -0.0005, parse = TRUE) +
    theme(legend.position = "none")
p2 <- pdist + geom_histogram()
p3 <- pspeed + geom_histogram()

p1 + (p2 / p3 + plot_layout(height = c(2, 1))) + plot_layout(width = c(2, 1))

```

\[
    p(\boldsymbol{y}_{k} | \boldsymbol{x}_{k}) = ??
\]

***
## Particle filter in action: likelihood

```{r,echo=FALSE,message=FALSE,warning=FALSE,fig.width=10,fig.height=4}
p1 <- ploop +
    geom_point(aes(lon, lat), data = state) +
    geom_point(aes(lon, lat), data = obs, colour = "red", size = 2) +
    geom_text(aes(lon, lat, label = "Y[k]"), data = obs, nudge_y = -0.0005, parse = TRUE)

R <- 6378137
rad <- function(x) x * pi / 180
deg <- function(x) x * 180 / pi
state <- state %>%
    mutate(
        xx = R * rad(lon - obs$lon) * cos(rad(obs$lat)),
        yy = R * rad(lat - obs$lat)
    )

p2 <- ggplot(aes(xx, yy), data = state) +
    geom_hline(yintercept = 0, lty = 3) +
    geom_vline(xintercept = 0, lty = 3) +
    geom_point() +
    geom_point(aes(0, 0), data = NULL, colour = "red") +
    coord_fixed(ratio = 1) +
    theme_classic() +
    theme(
        axis.line = element_blank()
    ) +
    labs(x = "East-West (m)", y = "North-South (m)")

p1 + p2 + plot_layout(width = c(2, 1))

```

\[
    d(\boldsymbol{y}_k | h(\boldsymbol{x}_k^{(i)}) = ||g(\boldsymbol{y}_k | h(\boldsymbol{x}_k^{(i)}) ||
    = ||\boldsymbol{r}_k^{(i)}||
\]

Assumption: $\boldsymbol{r}_k \sim \mathcal{N}(\boldsymbol{0}, \epsilon^2\mathbf{I})$

Therefore: $d(\boldsymbol{y}_k | h(\boldsymbol{x}_k^{(i)})^2 \sim \mathcal{E}\left(\frac{1}{2\epsilon^2}\right)$


***
## Particle filter in action: update

```{r,echo=FALSE,message=FALSE,warning=FALSE,fig.width=10,fig.height=4}

state <- state %>%
    mutate(wt = dexp(xx^2 + yy^2, 1 / (2 * 20^2))) %>%
    mutate(wt = wt / sum(wt)) %>%
    mutate(wt.scale = wt / max(wt) * 0.5 + 0.5)

p1 <- ploop +
    geom_point(aes(lon, lat, size = sqrt(wt)), data = state) +
    geom_point(aes(lon, lat), data = obs, colour = "red", size = 2) +
    geom_text(aes(lon, lat, label = "Y[k]"), data = obs, nudge_y = -0.0005, parse = TRUE) +
    theme(legend.position = "none")
p2 <- pdist + geom_histogram(aes(weight = wt), data = state)
p3 <- pspeed + geom_histogram(aes(weight = wt), data = state)

p1 + (p2 / p3 + plot_layout(height = c(2, 1))) + plot_layout(width = c(2, 1))

```

\[
    w_k^{(i)} = \frac{w_{k-1}^{(i)} p(\boldsymbol{y}_k | \boldsymbol{x}_k^{i})}{\sum_{j=1}^N w_{k-1}^{(j)} p(\boldsymbol{y}_k | \boldsymbol{x}_k^{j})}
,\quad
    p(\boldsymbol{x}_{k} | \boldsymbol{y}_{1:k}) \approx
    \sum_{i=1}^N w_{k}^{(i)} \delta_{\boldsymbol{x}_{k}^{(i)}} (\boldsymbol{x}_{k})
\]

***
## Particle filter to estimate vehicle state

* Easy to model vehicle behaviour
    * acceleration/deceleration
    * bus stop dwell times
    * intersections
* Multimodality
    * bus stops
    * loops
    * bad data
* Easy estimation of other quantities ...
    * travel time/average speed along road segments

\[
    p(b_\ell | \boldsymbol{y}_{1:k}) \approx
    \sum_{i=1}^N w_{k}^{(i)} \delta_{b_{\ell}^{(i)}} (b_{\ell})
\]

***
## Particle filter to predict arrival times

* Each particle travels to end of route
    * average segment speeds (distribution)
    * dwell times and layovers
    * intersections
* Arrival times $\alpha_j$ recorded

\[
    p(\alpha_j | \boldsymbol{\beta}_{\mathcal{T},k}, \mathcal{T}_{k}) \approx
    \sum_{i=1}^N w_{k}^{(i)} \delta_{\alpha_{j}^{(i)}} (\alpha_{j})
\]

* Sped up using a weighted subsample size $N^\star$

\[
    p(\alpha_j | \boldsymbol{\beta}_{\mathcal{T},k}, \mathcal{T}_{k}) \approx
    \frac{1}{N^\star} \sum_{i=1}^{N^\star} \delta_{\alpha_{j}^{(i)}} (\alpha_{j})
\]


***
## Particle filter to predict arrival times

* Implemented to full day of data (Auckland)
* After, match predictions with actual arrivals
* Examine prediction accuracy
    * RMSE, MAE
    * MAPE (~only short-term forecasts)
    * PICP (5 and 90% particle quantiles)
* Compare to GTFS (single point estimate, schedule + current delay)


***
## Particle filter to predict arrival times

```{r,echo=FALSE,eval=FALSE}
eta_files <- list.files("~/Documents/uni/phd-thesis/chapters/chapter05/data",
    pattern = "eta_results.\\.rda",
    full.names = TRUE
)
eta_results_all <-
    do.call(bind_rows,
        lapply(eta_files, function(f) {
            load(f)
            etai
        })
    ) %>%
    ungroup()

eta_talk <- eta_results_all %>%
    select(
        stop_sequence, timestamp,
        pf_mean, pf_var, pf_lower, pf_upper, pf_error, pf_ci,
        scheduled_arrival, actual_arrival, delay,
        time_until_arrival, current_delay,
        gtfs_arrival_time, gtfs_eta, gtfs_error
    )

save(eta_talk, file = "etadata.rda")
```

```{r,echo=FALSE,fig.width=10,fig.height=6,message=FALSE,warning=FALSE,cache=TRUE}
# rmse - time of day
load("etadata.rda")
res_timeofday <- eta_talk %>%
    mutate(
        hour = timestamp %>% format("%H") %>% as.integer,
        minute = timestamp %>% format("%M") %>% as.integer,
        hour = hour + (floor(minute / 15) * 15 / 60)
    ) %>%
    filter(time_until_arrival > 0) %>%
    group_by(hour) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>% arrange(hour)

pal <- viridis::magma(3)[2:1] #RColorBrewer::brewer.pal(2, "Set1")
names(pal) <- c("Particle filter", "GTFS")

plot_base <- ggplot(res_timeofday, aes(hour)) +
    theme_classic() +
    theme(legend.position = "none") +
    scale_colour_manual(values = pal, name = "") +
    xlab("Time of day (hour)")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "Particle filter")) +
    geom_path(aes(y = gtfs_rmse, colour = "GTFS"), alpha = 0.5) +
    scale_y_continuous(
        "RMSE (s)"
        # trans = "log10"
    ) +
    theme(legend.position = "bottom")

plot_mae <- plot_base +
    geom_path(aes(y = pf_mae, colour = "Particle filter")) +
    geom_path(aes(y = gtfs_mae, colour = "GTFS"), alpha = 0.5) +
    scale_y_continuous(
        "MAE (s)"
        # trans = "log10"
    )

plot_mape <- plot_base +
    geom_path(aes(y = 100 * pf_mape, colour = "Particle filter")) +
    geom_path(aes(y = 100 * gtfs_mape, colour = "GTFS"), alpha = 0.5) +
    scale_y_continuous(
        "MAPE (%)"
        # trans = "log10"
    )

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 85), lty = 2) +
    geom_path(aes(y = 100 * pf_ci_cov, colour = "Particle filter")) +
    scale_y_continuous(
        name = "PICP (%)"
    )

plot_rmse + plot_mae +
    plot_mape + plot_ci +
    guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
            55
        ",
        heights = c(1, 1, 0.1)
    )

```

***
## Particle filter to predict arrival times

* Generally better than GTFS estimate
* Captures uncertainty during daytime off-peak
    * difficulty forecasting peak times (model not implemented)


# Conclusion

* GTFS network
    * match observations to physical roads
* Particle filter
    * flexible, multimodality, simple likelihood, estimation of road speeds
* Network state
    * updated in real-time from speed estimates, extensible (forecasts)
* Predictions
    * real-time network state, dwell times
* Journey planning
    * simplified CDF easy to share, calculate event probabilities<br><br>
* `transitr` R package
    * future research, deployment


# Thank you


# References
<div id="refs"></div>


# Appendix

- [Information filter](#information-filter)


# Information filter

## Predict

* use standard Kalman filter prediction equations

\[
\begin{split}
    \hat\beta_{c|c-1} &= \hat\beta_{c-1|c-1} \\
    P_{c|c-1} &= P_{c|c-1} + (\Delta_c q)^2
\end{split}
\]

***
## Information fitler: update

* Information matrix, vector \[U = P^{-1}, \quad u = \hat\beta P^{-1}\]
* Obs. inf. matrix, vector; *include between-vehicle variance*
  \[I_v = (\phi^2 + e_v^2)^{-1},\quad i_v = b_v (\phi^2 + e_v^2)^{-1}\]
* Sum everything together
\[
    \begin{split}
    U_{c|c} = U_{c|c-1} + \sum_v I_{v,c} \\
    u_{c|c} = u_{c|c-1} + \sum_v i_{v,c}
    \end{split}
\]
* Back-transform
