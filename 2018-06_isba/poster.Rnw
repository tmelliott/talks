\documentclass[plainboxedsections,landscape,20pt]{sciposter}

\usepackage{multicol}
\usepackage{amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{wrapfig}
\usepackage{cite}
\usepackage{subfig}
% \usepackage{sidecap}

\definecolor{BoxCol}{rgb}{0.01,0.31,0.52}
\definecolor{SectionCol}{rgb}{1,1,1}

\setlength{\figtopskip}{0pt}
\setlength{\figbotskip}{0pt}


% \norightlogo
\leftlogo{figs/UOA-VC-RGB}
% \title{Improving bus arrival-time estimates\\
%     \Huge{using real-time vehicle positions to estimate road state}}
\title{How can be improve bus ETAs?\\
    {Using real-time position data to estimate road state}}
\author{Tom Elliott and Thomas Lumley}
\institute{Department of Statistics, University of Auckland, New Zealand}
\email{tom.elliott@auckland.ac.nz}
\conference{2018 ISBA World Meeting, Edinburgh, UK, June 24--29 2018}

\newcommand{\bX}{\boldsymbol X}
\newcommand{\bY}{\boldsymbol Y}
\newcommand{\bR}{\boldsymbol R}
\newcommand{\bv}{\boldsymbol v}

<<knitr,echo=FALSE>>=
knitr::opts_chunk$set(message=FALSE,warning=FALSE,results='hide',echo=FALSE)
@

<<libraries>>=
suppressPackageStartupMessages({
    library(tidyverse)
    library(ggplot2)
    library(dbplyr)
    library(RSQLite)
    library(ggmap)
    library(egg)
})

<<r_setup,cache=TRUE>>=
gtfs.db <- "../../TransitNetworkModel/gtfs.db"
gtfs <- dbConnect(SQLite(), gtfs.db)

shapeid <- gtfs %>% tbl("routes") %>% select(shape_id, route_id) %>%
    filter(route_id %like% "27401%") %>%
    head(1) %>% collect %>% pluck('shape_id')
shape <- gtfs %>% tbl("shapes") %>%
    filter(shape_id == shapeid) %>% arrange(seq) %>% collect

dbDisconnect(gtfs)

shp <- shape %>% filter(between(dist_traveled, 2700, 3800))
xr = extendrange(shp$lng, f = 2) 
yr = extendrange(shp$lat)
bbox = c(xr[1], yr[1], xr[2], yr[2])
akl = get_stamenmap(bbox, zoom = 16, maptype = "toner-hybrid")

map <- ggmap(akl) +
    geom_path(aes(lng, lat), data = shape, color = "skyblue2",
              alpha = 0.9, lwd = 2) +
    theme(axis.text = element_blank(), 
          axis.ticks = element_blank(),
          panel.grid.major = element_blank()) + xlab("") + ylab("")


bearing <- function(a, b) {
    ## convert to radians!!
    lam.a <- a[1] * pi / 180
    lam.b <- b[1] * pi / 180
    phi.a <- a[2] * pi / 180
    phi.b <- b[2] * pi / 180
    th.rad <- atan2(sin(lam.b - lam.a) * cos(phi.b),
                    cos(phi.a) * sin(phi.b) - sin(phi.a) * cos(phi.b) * cos(lam.b - lam.a))
    (th.rad * 180 / pi) %% 360
}

partialSegment <- function(x, theta, d, R = 6371000) {
    ## Compute the Lat/Lon after traveling distance D
    ## from point X at a bearing of THETA
    
    delta <- d / R ## for single calculation
    theta <- theta * pi / 180  ## convert to radians
    phi.s <- x[2] * pi / 180
    lam.s <- x[1] * pi / 180
    
    phi.z <- asin(sin(phi.s) * cos(delta) + cos(phi.s) * sin(delta) * cos(theta))
    lam.z <- lam.s + atan2(sin(theta) * sin(delta) * cos(phi.s),
                           cos(delta) - sin(phi.s) * sin(phi.z))
    c(phi.z, lam.z) * 180 / pi
}
h <- function(d, sh) {
    i <- which(sh$dist_traveled > d)[1]
    if (sh$dist_traveled[i-1] == d) return(c(sh$lat[i-1], sh$lng[i-1]))
    a <- c(sh$lng[i-1], sh$lat[i-1])
    b <- c(sh$lng[i], sh$lat[i])
    theta <- bearing(a, b)
    partialSegment(a, theta, d - sh$dist_traveled[i-1])
}


p <- dget("particles.dat") %>% as.tibble
T <- unique(p$timestamp)

set.seed(2)
dobs <- 3300
Yobs <- h(dobs, shape) + rnorm(2, 0, 0.0001)
@


\begin{document}
\maketitle
% \vspace{-0.5em}
\begin{minipage}[t]{0.59\linewidth}
    \section{Introduction}

    

    \begin{itemize}
        \item real time information (RTI) has become an important component
            of public transit systems, providing commuters with up to date 
            information on the location and estimated arrival time (ETA) of buses
        \item transit vehicle tracking has been used for several decades to obtain
            ETAs, with much research into methods for improving the vehicle models used
            \cite{Wall99analgorithm,Dailey_2001,Cathey_2003,Hans_2015}
        \item the main source of uncertainty is congestion, particularly in networks with poor
            public tranport infrastructure (e.g., dedicated bus lanes)
        \item research shows that ETA accuracy can be improved by using travel time
            information from previous buses along a road \cite{Yu_2011},
            however this only applied to a specific, manually selected road
        \item {we propose a generalised approach to modeling transit vehicles 
            and network congestion}
        \begin{itemize}
            \item a vehicle model estimates vehicle speed/travel time along a road
            \item the state (vehicle speed) of the road is updated to reflect real-time
                congestion
            \item ETAs are updated using congestion information along all intermediate roads
        \end{itemize}
    \end{itemize}

% \end{minipage}
% \begin{minipage}[t]{0.59\linewidth}
\begin{minipage}[t]{0.33\linewidth}
    \section{GTFS network construction}
    % \textbf{Goal:} to represent each bus route as a sequence of
    % physical road segments between intersections.
    \begin{itemize}
        \item \textbf{GTFS} is an API specification for transit data \cite{GoogleDevelopers_2006}, and includes route shape information
        \item available in over 500 locations worldwide
        \item \textbf{transit network} consisting of intersections and connecting road segments
            constructed from the raw GTFS data  
    \end{itemize}

    \begin{enumerate}
        \item raw GTFS data provides \textbf{one shape per route}
        \item \textbf{identify points of intersection} between one or more routes using algorithm adapted from 
            \cite{Zhang_2017}
        \item \textbf{split shapes at intersections} to obtain shapes for each individual road segment
        \item express each route as a sequence of road segments
    \end{enumerate}

    \begin{figure}
        \centering
        \includegraphics{figs/gtfs-nw_figure1}
        \hspace{2em}
        \includegraphics{figs/gtfs-nw_figure2}
        \caption{An example transit netork produced from five routes. Left: the raw GTFS shapes; Right: the generated transit network with intersections shown as dots.}
    \end{figure}

    \begin{itemize}
        \item Implementation in progress: the \texttt{gtfsnetwork} R package, github.com/tmelliott/gtfsnetwork
    \end{itemize}

    \bibliographystyle{unsrt}
    {\footnotesize\bibliography{reflist}}

% \end{minipage}
% \hspace{0.04\linewidth}
% \begin{minipage}[t]{0.38\linewidth}
%     \section{Objectives}
%     \begin{itemize}
%         \item estimate real-time state (including speed) of buses using sparse (approx.\ 30~seconds) GPS observations
%         \item construct a road network (intersections connected by road segments) from GTFS route shape data
%         \item map real-time positions to a physical road segment, and update its state
%         \item use road state estimates to predict future travel times 
%     \end{itemize}
\end{minipage}
\hspace{0.01\linewidth}
\begin{minipage}[t]{0.65\linewidth}
    \section{Vehicle state model}
    \label{sec:pf}

    % \textbf{Goal:} to estimate the state $\bX_k$ of a bus (trip distance traveled and speed)
    %     from GPS positions, $\bY_k$, at time $t_k$, in real-time
    \begin{itemize}
        % \vspace{1em}
        \item sequential Bayesian methods well suited to \textbf{real-time vehicle tracking}
        \item in Auckland, GTFS realtime positions obtained approximately every 30 seconds,
            but high variability


    % \end{itemize}

    \begin{minipage}[t]{0.49\linewidth}


        % \end{itemize}
    % \end{minipage}
    % \begin{minipage}{0.49\linewidth}
<<vehicle_state_initial,fig.width=5,fig.height=3,out.width='\\linewidth',fig.align='center'>>=
p1 <- p %>% filter(k == 1 & between(t, T[1], T[2]))

set.seed(1)
pids <- p1 %>% filter(d < 2820) %>% pluck('particle_id') %>%
    unique %>% sample(10)

p1f <- p1 %>% filter(particle_id %in% pids)
x1 <- ggplot(p1f %>% filter(t == T[1])) +
    geom_point(aes(t, d), col = "orangered", size = 3, pch = 19) +
    scale_x_datetime(breaks = T[1:2], limits = T[1:2],
        labels = c(expression(t[k-1]), expression(t[k]))) +
    # xlim(T[1], T[2]) + #ylim(min(p1f$d), max(p1f$d)) +
    xlab("Time") + ylab("Distance traveled") + ylim(2700, 3800) +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.text.x = element_text(size = 14),
          panel.grid.major.y = element_blank(),
          panel.grid.minor = element_blank())# +
#    geom_vline(xintercept = T[2], lty = 2, colour = "red")


dx1 <- sapply(p1f %>% filter(t == T[1]) %>% pluck('d'), h, sh = shape) %>%
    t %>% as.tibble %>% mutate(lat = V1, lng = V2) %>% select(lat, lng)
m1 <- map + geom_point(aes(lng, lat), data = dx1, colour = "orangered",
                       size = 2, stroke = 2, pch = 21, fill = "white") +
    geom_point(aes(x = Yobs[2], y = Yobs[1]), pch = 4, colour = "red",
               size = 1.5, stroke = 2)
# ggarrange(x1, m1, widths = c(3, 1))
@
    % \end{minipage}

    % \begin{minipage}{0.49\linewidth}
    %     \begin{itemize}


        \item \textbf{particle filter}: general, flexible estimation method 
            \begin{itemize} 
                \item vehicle state approximated by a sample of particles 
                    $\tilde\bX_k =(\bX_k^{(i)})_{i=1}^N$
                \item particles transitioned independently,
                    so multimodal distributions are no issue
                    (e.g., at bus stops and intersections)
                \item likelihood is intuitive: the distance between the estimated
                    and observed location
            \end{itemize}
        \item measurement function $h:\mathbb{R}\mapsto\mathbb{R}^2$ calculates 
            particle's map position from distance traveled along shape
        \item our particle filter estimation procedure is as follows:

        \begin{enumerate}
            \item predict trajectory of each particle 
                using transition function $f$ and system noise parameter $Q_k$
                as shown in figure~\ref{fig:vehicle_state_update1}
                \begin{equation*}
                    \bX_k^{(i)} = f(\bX_k^{(i)}, w_k),\quad
                    w_k \sim N(0, Q_{k-1})
                \end{equation*}
        
        
    %     \end{itemize}
    % \end{minipage}
    % \hspace{0.01\linewidth}
    % \begin{minipage}{0.49\linewidth}
<<vehicle_state_predict,fig.width=5,fig.height=3,out.width='\\linewidth',fig.align='center'>>=
x2 <- x1 + geom_path(aes(t, d, group = particle_id),
                     data = p1f, lty = 2) +
    geom_point(aes(t, d), data = p1f %>% filter(t == T[2]),
               size = 1.5, pch = 19)

dx2 <- sapply(p1f %>% filter(t == T[2]) %>% pluck('d'), h, sh = shape) %>%
    t %>% as.tibble %>%
    mutate(id = p1f %>% filter(t == T[2]) %>% pluck('particle_id'),
           lat = V1, lng = V2) %>%
    select(id, lat, lng)
m2 <- map +
    geom_point(aes(lng, lat), data = dx2, colour = "black", size = 2, stroke = 2,
               pch = 21, fill = "white") +
    geom_point(aes(x = Yobs[2], y = Yobs[1]), pch = 4, colour = "red",
               size = 1.5, stroke = 2)
# ggarrange(x2, m2, widths = c(3, 1))
@
    % \end{minipage}

    % \begin{itemize}
            \item assume $\bY_k$ is a noisy measurement of true 
                position with GPS error $\sigma^2_y$ (fig~\ref{fig:vehicle_state_update2}),
                and define $g:\mathbb{R}^2\mapsto\mathbb{R}^2$ such that
                $\mathit{dist}(g(\bY_1), g(\bY_2))$ is the ground distance between
                the points, then the measurement model is
                \begin{equation*}
                    g(\bY_k) \sim N\left(g(h(\bX_k)), 
                    \begin{bmatrix}
                        \sigma^2_y & 0 \\ 0 & \sigma^2_y
                    \end{bmatrix}
                    \right)
                \end{equation*}
                and $(\delta_k^{(i)})^2 = \mathit{dist}(g(h(\bX_k^{(i)})), g(Y_k))^2$
                is the sum of two independent normal r.v.'s with mean 0 and 
                variance $\sigma^2_y$
                \begin{equation*}
                    \left((\delta_k^{(i)})^2 / \sigma_y^2\right)
                    \sim \chi^2(2) \sim \mathrm{Exp}(0.5) 
                \end{equation*}
            \item evaluated the likelihood for each particle
                \begin{equation*}
                    p(\bY_k | \bX_k^{(i)}) = 0.5e^{-(\delta_k^{(i)})^2 / 2\sigma_y^2}
                \end{equation*}
            \item update state by resampling particles with replacement, using likelihood weights (fig~\ref{fig:vehicle_state_update3})
                \begin{equation*}
                    w^{(i)} = p(\bY_k | \bX_k^{(i)}) / \sum_{j=1}^N p(\bY_k | \bX_k^{(j)})
                \end{equation*}
            \item use resulting trajectories to estimate vehicle speed along 
                road segments to update network in section~\ref{sec:nw}
        \end{enumerate}


        % \begin{itemize}
        %     \item Particle filter is a computationally intensive estimation method;
        %         however, using an 8~core, 32~GB RAM Virtual Machine, 
        %         we are able to model all buses in Auckland (1000+ at peak hour)
        %         in under 20 seconds.
        % \end{itemize}
    \end{minipage}
    \hspace{0.01\linewidth}
    \begin{minipage}[t]{0.49\linewidth}
<<vehicle_state_update,fig.width=5,fig.height=2.5,out.width='\\linewidth',fig.align='center',fig.cap=c('Left: simulated particle trajectories. Right: particle positions $h(\\bX_k^{(i)})$; observation $\\bY_k$ in red.','$\\bY_k$ (red cross) is a bivariate normal r.v. with mean and variance represented by the black dot and concentric rings, respectively.','After resampling, a posterior sample of trajectories is obtained (orange).'),fig.scap=NA>>=
ll <- dnorm(p1f %>% filter(t == T[2]) %>% pluck("d"), dobs, 20)
wt <- ll / sum(ll)

idk <- sample(p1f$particle_id %>% unique, prob = wt, replace = TRUE)

p3 <- p1f %>% mutate(keep = ifelse(particle_id %in% idk, "yes", "no"))
x3 <- x1 + geom_path(aes(t, d, group = particle_id, colour = keep,
                         lty = keep),
               data = p3) +
    scale_colour_manual(values = c("yes" = "orangered", "no" = "gray")) +
    scale_linetype_manual(values = c("yes" = 1, "no" = 2)) +
    geom_point(aes(t, d, colour = keep, size = keep),
               data = p3 %>% filter(t == T[2])) +
    scale_size_manual(values = c("yes" = 3, "no" = 1)) +
    theme(legend.position = 'none')

dx3 <- dx2 %>% mutate(keep = ifelse(id %in% idk, "yes", "no"))
m3 <- map +
    geom_point(aes(lng, lat, colour = keep),
               data = dx3 %>% arrange((keep)),
               size = 2, stroke = 2, pch = 21, fill = "white") +
    scale_colour_manual(values = c("yes" = "orangered", "no" = "gray")) +
    theme(legend.position = "none")

oi = 1
xr = extendrange(dx2$lng[oi]+c(-0.005, 0.005))
yr = extendrange(dx2$lat[oi]+c(-0.0001,0.0001))
bbox = c(xr[1], yr[1], xr[2], yr[2])
akl = get_googlemap(dx2[oi,c('lng', 'lat')] %>% as.numeric, zoom = 20,
    maptype="roadmap")
map <- ggmap(akl) +
    geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf),
            fill = "white", alpha = 0.1) +
    geom_point(aes(lng, lat), data = dx2[oi,], pch = 21, size = 3, stroke = 2,
               fill = "white") + 
    geom_point(aes(lng, lat), data = dx2[oi, ], pch = 21, size = 30, stroke = 1,
                fill = "transparent", color='black') +
    geom_point(aes(lng, lat), data = dx2[oi, ], pch = 21, size = 60, stroke = 0.5,
                fill = "transparent", color='black') +
    ## arrow from particle to obs
    # geom_segment(aes(dx2$lng[oi]+0.000006, dx2$lat[oi]-0.000015, 
    #                  xend = Yobs[2]-0.000015, yend = Yobs[1]+0.00003), 
    #              data = NULL, lwd = 1.5,
    #              arrow = arrow(length = unit(5, 'mm'))) +
    geom_point(aes(Yobs[2], Yobs[1]), pch = 4, colour = "red",
               size = 5, stroke = 2) + 
    theme(axis.text = element_blank(), 
          axis.ticks = element_blank(),
          panel.grid.major = element_blank()) + xlab("") + ylab("")


ggarrange(x2, m2, widths = c(3, 1))
map
ggarrange(x3, m3, widths = c(3, 1))
@
    \end{minipage}
    \end{itemize}

\end{minipage}
\end{minipage}
\hspace{0.01\linewidth}
\begin{minipage}[t]{0.39\linewidth}
    \section{Network state model}
    \label{sec:nw}


    \begin{minipage}[t]{0.49\linewidth}
        \begin{itemize}
            \item network model to estimate and predict network state
            \item segment $j$ has state $\beta^j_r$ (vehicle speed) 
                at time $t_r$ with variance $P^j_r$
            \item estimate state using an adapted extended Kalman filter (EKF) algorithm
            \item Step 1: predict future state
            \begin{itemize}
                \item define \textbf{transition function} $a$ such that the state converges to the prior 
                    (fig.~\ref{fig:road_state1})
                \item \text{prior mean speed} $\mu_j(t)$ and variance $\psi_j(t)$
                    at time~$t$ from \textbf{historical data} (blue lines in fig.~\ref{fig:road_state1})
                \item use EKF equations to recursively predict state in 1~second intervals
                \item define \textbf{system noise} so $P^j_r$ converges to $\psi_j(t_r)$
            \end{itemize}

            \item Step 2: update state when observations recieved from step~5 in section~\ref{sec:pf}
                (red point fig.~\ref{fig:road_state2})
            \begin{itemize}
                \item \textbf{measurement error:} variance of particle speeds 
                \item use EKF update equations to update state at time of observation
            \end{itemize}
        \end{itemize}
    \end{minipage}
    \hspace{0.01\linewidth}
    \begin{minipage}[t]{0.49\linewidth}
<<road_state,fig.width=5,fig.height=2,out.width='\\textwidth',fig.align="center",fig.cap=c('Road state $\\hat\\beta^j$ (with variance $P^j_r$, dashed black lines) converge to the prior (blue lines).','After recieving a vehicle speed estimate (red dot), the state is updated.'),fig.scap=NA>>=
X <- x <- 20
P <- p <- 2
n <- 30
lambda <- 0

KF <- function(x, P, mu, sigma, delta, lambda = 1/600,
               keep = FALSE) {
    if (keep) {
        hist <- list(x = numeric(delta)+1, P = numeric(delta)+1)
    }
    hist$x[1] <- x
    hist$P[1] <- P
    for (i in 1:delta) {
        l <- P / (P + sigma)
        x <- x + l*lambda * (mu - x)
        q <- (1 - (1 - l*lambda)^2) * sigma
        P <- (1 - l*lambda)^2 * P + q
        ##P <- P + lambda * (x / (x + mu))^2 * (sigma - P)
        hist$x[i+1] <- x
        hist$P[i+1] <- P
    }
    o <- list(x = x, P = P)
    if (keep) o$hist <- hist
    o
}

pmean <- 30
pvar <- 30
r <- KF(20, 1, pmean, pvar, 3600, lambda=1/300, keep = TRUE)
r <- r$hist %>%
    as.tibble %>%
    add_column(i = 1:nrow(.)-1L, .before = 1)
ti <- 5*60+1
obsx <- 19
obsv <- 1
p0 <- ggplot(r, aes(i/60)) +
    geom_hline(yintercept = pmean + sqrt(pvar) * c(0, -1, 1),
               lty = 2, lwd = c(1.5, 1, 1), col = "steelblue") +
    geom_line(aes(y = pmax(0, x - sqrt(P))), lty = 2) +
    geom_line(aes(y = pmax(0, x + sqrt(P))), lty = 2) +
    geom_line(aes(y = x), lwd = 1.5) +
    xlab("Time since last observation (min)") + ylab("Road speed (km/h)")

p1 <- p0 #+ geom_pointrange(aes(x = 5, y = obsx, ymin = obsx-obsv, ymax = obsx+obsv),
         #           data = NULL, col = "red", fill = "white", pch = 21)
r2 <- KF(x, p, pmean, pvar, 3600-60*5, lambda=1/300, keep = TRUE)
r2 <- r2$hist %>%
    as.tibble %>%
    add_column(i = 1:nrow(.)-1L + 60*5, .before = 1)
p3 <- ggplot(r, aes(i/60)) +
    geom_hline(yintercept = pmean + sqrt(pvar) * c(0, -1, 1),
               lty = 2, lwd = c(1.5, 1, 1), col = "steelblue") +
    geom_line(aes(y = pmax(0, x - sqrt(P))), lty = 2, data = r,
              color = "gray") +
    geom_line(aes(y = pmax(0, x + sqrt(P))), lty = 2, data = r,
              color = "gray") +
    geom_line(aes(y = x), data = r, color = "gray") +
    geom_line(aes(y = x), data = r2) +
    geom_line(aes(y = x - sqrt(P)), data = r2, lty = 2) +
    geom_line(aes(y = x + sqrt(P)), data = r2, lty = 2) +
    xlab("Time since last observation (min)") + ylab("Road speed (km/h)") +
    geom_pointrange(aes(x = 5, y = obsx, ymin = obsx-obsv, ymax = obsx+obsv),
                    col = "red", fill = "white", pch = 21)

# ggarrange(p1, p3, heights = c(1, 1))
p1
p3
@
    
    \end{minipage}

    \section{Predicting arrival time}

    \begin{minipage}[t]{0.59\linewidth}
        \begin{itemize}
            \item for each particle, simulate journey along remainder of route
            \item \textbf{simulate speed} $v^j_t \sim N(\hat\beta^j_t, P^j_t)$ 
                for each upcoming segment $j$
            \item simulate intersection and bus stop wait times
                and compute arrival time at each upcoming stop
            \item resulting ETA distribution can be conveyed to passengers
            \begin{itemize}
                \item a point estimate 
                \item and/or a prediction interval (for commuters, this would be understood as a min and ``max'' wait time)
            \end{itemize}
            \item ETAs are typically reported in discrete minutes.
                For the example in figure~\ref{fig:predict_eta}, the distribution might be summarised with
            \begin{itemize}
                \item a \textbf{point estimate} of 5~minutes
                \item a \textbf{prediction interval} of 4--8~minutes
            \end{itemize}
            \item summary statistics need to be chosen such that,
                as the bus approaches, the estimates decrease
        \end{itemize}
    \end{minipage}
    \hspace{0.01\linewidth}
    \begin{minipage}[t]{0.39\linewidth}
<<predict_eta,fig.width=4,fig.height=3,out.width='\\textwidth',fig.align="center",fig.cap='Top: travel time predictions for a bus, showing locations of stops (left axis) and intersections (right axis). Bottom: posterior density of ETAs for stop 3.',fig.scap=NA>>=
set.seed(928346)
N <- 50
x <- runif(N, 1000, 1050)
Sd <- c(1400, 1800, 2500)
Rd <- c(1600, 2200)
d <- sort(c(Sd, Rd))
dat <- tibble(id = integer(), t = numeric(), d = numeric())
for (i in 1:N) {
    w <- rexp(5, 1/10)
    s <- rnorm(3, c(12, 10, 12), c(2, 3, 1))
    ss <- s[sapply(d, function(z) sum(Rd < z) + 1)]
    tt <- diff(c(x[i], d)) / ss
    tarr <- cumsum(tt) + c(0, cumsum(w[-length(w)]))
    tdep <- tarr + w
    dd <- c(x[i], rep(d, each = 2))
    dd <- dd[-length(dd)]
    tt <- sort(c(0, tarr, tdep[-length(tdep)]))
    dat <- dat %>% bind_rows(tibble(id = rep(i, length(dd)), t = tt, d = dd))
}
p1 <- ggplot(dat, aes(t/30, d, group = id)) + 
    geom_path(lwd = 0.2) + 
    scale_y_continuous(breaks = Sd, minor_breaks = Rd,
        labels = paste('Step', 1:3),
        sec.axis = sec_axis(breaks = Rd, trans = ~., labels = paste('Int', 1:2))) +
    scale_x_continuous(breaks = 0:4*2) +
    xlab('ETA (minutes)') + ylab('Distance traveled')
p2 <- ggplot(dat[dat$d == Sd[3], ], aes(t/30)) +
    geom_density() +
    scale_x_continuous(breaks = 0:4*2, limits = c(0, max(dat$t/30))) +
    theme(panel.grid.y.minor = NULL) +
    xlab('ETA (stop 3)') + ylab('Pr(ETA | Y)')
gp1 <- ggplotGrob(p1)
gp2 <- ggplotGrob(p2)
gp2$widths <- gp1$widths
gp1$hheights[1:5] <- unit('0','pt')
gp2$heights[1:5] <- unit('0','pt')
gridExtra::grid.arrange(gp1, gp2, heights = c(2, 1))
@
    \end{minipage}

    \section{Conclusion and future work}

    \begin{itemize}
        \item segmenting routes into route-independent segments allows vehicle observations to
            update the road network
        \item real-time network state used to predict arrival time
    \end{itemize}
    \textbf{Next steps:}
    \begin{itemize}
        \item improve the network state model:
            variable speeds along a roads (i.e., $\mu_j(t, d)$ depends on time and distance along segment),
            include covariates in state transition (adjacent segments, yesterday's traffic, weather, etc.)
        \item develop a stop-time and intersection-wait time model to more accurately predict
            wait times
        \item investigate ideal summary statistics for ETAs (both point and interval prediction)
    \end{itemize}


\end{minipage}


\end{document}