---
title: Traffic flows<br>&amp;</br>bus prediction
author: "<img src='double-decker-2016.jpg' width=450><br>
<small>Tom Elliott</small>"
date: "<small>PhD Talks Day 2019</small>"
output: 
    revealjs::revealjs_presentation:
        theme: sky
        center: true
        slide_level: 1
        mathjax: default
        reveal_options:
            controls: false
            hash: true
        transition: none
---


# Overview

GPS positions

$\downarrow$

Travel times

$\downarrow$

Network state

$\downarrow$

Arrival time distributions

$\downarrow$

ETAs


# <small>Part One</small><br>GPS positions<span style="margin:0.5em;display:block">$\downarrow$</span>travel times

----

<h2>Real-time vehicle locations</h2>

- Auckland Transport provides API for real-time data 
- __Vehicle locations__: GPS coordinates of buses/trains
- __Trip updates__: arrival/departure times at bus stops
<div style="margin-bottom:1em"></div>
- Over 1000 buses operating at peak
- Target: ETAs updated every 30 seconds


----
<h2>Vehicle state</h2>

- Unknown vehicle state $X_k = [x_k, \dot x_k]^\top$, at time $t_k$
    - $x_k$: distance travelled along route, meters
    - $\dot x_k$: speed, meters per second
- Observable state $Y_k = h(X_k) + \epsilon_k$

----

```{r,echo=F,fig.height=5,fig.width=7,out.width="100%"}
par(mar = c(4.1, 4.1, 2.1, 2.1))
layout(rbind(c(0, 1, 1, 1, 1, 0), c(2, 2, 2, 3, 3, 3)))
dist <- 5*c(0, 100, 400, 580, 650, 900, 1100, 1250, 1300, 1380, 1500)
plot(spline(0:10, dist/1e3, n = 1001, method = "hyman"), type = "l",
    xlab = "Time (min)", ylab = "Distance (km)",
    lty = 2, lwd = 2,
    main = "Vehicle state, X")
tk <- 5
X <- dist[6]
points(tk, X/1e3, col = "orangered", pch = 19, cex=1.5)

shape <- read.csv('shape.csv')
shape <- shape[nrow(shape):1,]
shape$dist <- cumsum(c(0, geosphere::distGeo(shape)[-nrow(shape)]))
shape <- shape[shape$dist <= max(dist),]
plot(shape$lon, shape$lat, type = 'l', col='steelblue', lwd=2,
    asp = cos(mean(shape$lat * pi / 180)),
    xlab = "Longitude (deg)", ylab = "Latitude (deg)",
    main = "Transformed vehicle state, h(X)")
Z <- shape[shape$dist > X, ][1,c("lon", "lat")]
points(Z, col = "orangered", pch = 19, cex=1.5)

shape <- shape[shape$dist > 3500 & shape$dist < 5500,]
plot(shape$lon, shape$lat, type = 'l', col='steelblue', lwd=2,
    asp = cos(mean(shape$lat * pi / 180)),
    xlab = "Longitude (deg)", ylab = "Latitude (deg)",
    main = "Vehicle observation, Y = h(X) + e")
points(Z, col = "orangered", pch = 19, cex=1.5)
set.seed(50)
Y <- Z + rnorm(2, 0, c(0.001, 0.001))
points(Y, pch = 19, cex=1.5)
```




----
<h2>Particle filter</h2>

- Approximate vehicle state using sample of $N$ particles
\[
p(X_{k-1} | Y_{1:k-1}) \approx
\sum_{i=1}^N W_{k-1}^{(i)} \delta_{X_{k-1}^{(i)}}(X_{k-1})
\]
- $X_{k-1}^{(i)}$: state (distance and velocity) of particle $i$
- $W_{k-1}^{(i)}$: weight of particle $i$
- $\delta_{x^{i}}(x)$: Dirac measure 
($\approx$ continuous version of $I_{x^i}(x)$)


----
<h2>Particle filter ii</h2>

- Predict new state using __vehicle transition function__, $f$

\[
X_k^{(i)} = f(X_{k-1}^{(i)}, \sigma_x^2, ...)
\]

\[
p(X_{k} | X_{k-1}) \approx
\sum_{i=1}^N W_{k-1}^{(i)} \delta_{X_k^{(i)}}(X_{k})
\]

----
<h2>Particle filter iii</h2>

- Vehicle likelihood function based on squared distance between particle and observation,
and GPS error $\epsilon^2$ <div style='margin-bottom: 0.5em'></div>
\[
d(Y_k, h(X_k^{(i)}))^2 \sim Exp\left(\frac{1}{2\epsilon^2}\right)
\]

- Update vehicle state by reweighting particles

\[
W_k^{(i)} = \frac{W_{k-1}^{(i)} p(Y_k | X_k^{(i)})}{\sum_{j=1}^N W_{k-1}^{(j)} p(Y_k | X_k^{(j)})}
\]

\[
p(X_k | Y_{1:k}) \approx
\sum_{i=1}^N W_{k}^{(i)} \delta_{X_k^{(i)}}(X_{k})
\]



----
<h2>Estimating travel times</h2>

- For road segment $j$ completed at time $t_k$, 
each particle has a known travel time $T_j$
- Posterior estimate of travel time easily computed
\[
p(T_j | Y_{1:k}) \approx
\sum_{i=1}^N W_{k}^{(i)} \delta_{T_j^{(i)}}(T_{j})
\]


# <small>Part Two</small><br>Travel times<span style="margin:0.5em;display:block">$\downarrow$</span>Network state

----
<h2>Transit road network</h2>

- __road network__ consists of all $M$ __road segments__
- each road segment
    - connects two intersections
    - is used by at least one (bus) route
    - doesn't overlap another road segment


----
<h2>Network state</h2>

- travel time (s) of buses along segments at time $t_c$
\[
\Theta_c = 
[
\theta_{1c}, \theta_{2c}, \cdots, \theta_{Mc}
]^\top
\]
- travel times observed as buses traverse the network
    - multiple buses may traverse a segment at a time

- assume state is multivariate normal
\[
\hat\Theta_{c|c} = \mathrm{E}(\Theta_c | T_{1:c})
\quad\text{and}\quad
\Xi_{c|c} = \mathrm{Var}(\Theta_c | T_{1:c})
\]


----
<h2>Information filter</h2>

- alternate form of Kalman filter
- represent mean and variance as __information matrix__ and __information vector__
\[
P_{c-1|c-1} = \Xi_{c-1|c-1}^{-1}
\quad\text{and}\quad
p_{c-1|c-1} = \Xi_{c-1|c-1}^{-1}\hat\Theta_{c-1|c-1}
\]
- allows summing of observation information over multiple observations


----
<h2>Information filter ii</h2>

- predict next state
    - assume travel times constant over short periods
    - system noise is $\rho^2$ (s/s)
- standard Kalman filter predict equations
\[
\begin{split}
\hat\Theta_{c|c-1} &= \hat\Theta_{c-1|c-1} \\
\Xi_{c|c-1} &= \Xi_{c-1|c-1} + I \rho^2
\end{split}
\]


----
<h2>Information filter iii</h2>

- transform travel time observations for each bus $\ell$ with measurement uncertainty $R_c$
    - $I_{c\ell} = R_c^{-1}$
    - $i_{c\ell} = R_c^{-1} T_{j\ell}$
- update state by adding information
\[
\begin{split}
P_{c|c} &= P_{c|c-1} + \sum_\ell I_{c\ell} \\
p_{c|c} &= p_{c|c-1} + \sum_\ell i_{c\ell}
\end{split}
\]
- back transform for state parameters


----
<h2>Information filter iv</h2>

- $M$ is big
- model segments independently to avoid inversing large state matrix
- include correlations between adjacent segments only in prediction using historical data
- real-time computation is now trivial scalar operations


# <small>Part Three</small><br>Network state<span style="margin:0.5em;display:block">$\downarrow$</span>Arrival time distrutions

----
<h2>Predicting arrival time</h2>

- when will the bus arrive at stop $m$ given
    - latest estimate of position/speed
    - current network state (traffic conditions)
- uncertainty from
    - position/speed estimate
    - traffic conditions now _and in the near future_
    - dwell time at stops (can be zero)
    - traffic lights, random traffic fluctuations, ...


----
<h2>Reprise the particle filter</h2>

\[
p(A_m | X_k, \Theta_c) \approx
\sum_{i=1}^N W_{k}^{(i)} \delta_{A_{m}^{(i)}}(A_m)
\]

- for each particle, simply run transition function $f$ 
- continue to end of route, recording stop arrival times
- simulate travel times from network state estimate

----
<h2>Maybe not ...</h2>

- requires simulating $N \times M_\text{remaining}$ arrival times
- for upwards of 1000 buses at peak times
- every 30 seconds ... 

----
<h2>(Work in progress)</h2>

- use particle filter to estimate next $M'$ stops
- predict remaining travel time using normal theory
- allow uncertainty to converge to prior (historical data)


----
<h2></h2>

```{r,echo=F}
set.seed(99)
N <- 1e5
X <- 0
theta <- c(60, 45, 120, 80)
xi <- c(15, 10, 20, 20)
T <- mvtnorm::rmvnorm(N, theta, diag(xi))
D1 <- rbinom(N, 1, 0.7) * (6 + pmax(0, rnorm(N, 30, 5)))
D2 <- rbinom(N, 1, 0.8) * (6 + pmax(0, rnorm(N, 25, 10)))
D3 <- rbinom(N, 1, 0.3) * (6 + pmax(0, rnorm(N, 15, 3)))
D4 <- rbinom(N, 1, 0.5) * (6 + pmax(0, rnorm(N, 20, 5)))
A1 <- D1 + T[,1]
A2 <- A1 + D2 + T[,2]
A3 <- A2 + D3 + T[,3]
A4 <- A3 + D4 + T[,4]

par(mfrow = c(4, 1), mar = c(4.1, 4.1, 2.1, 2.1))
hist(A1/60, 40, xlim = range(0, A1, A2, A3, A4) / 60, main = "", 
     prob = TRUE, xlab = "Stop 1 ETA (min)")
hist(A2/60, 40, xlim = range(0, A1, A2, A3, A4) / 60, main = "", 
     prob = TRUE, xlab = "Stop 2 ETA (min)")
hist(A3/60, 40, xlim = range(0, A1, A2, A3, A4) / 60, main = "", 
     prob = TRUE, xlab = "Stop 3 ETA (min)")
hist(A4/60, 50, xlim = range(0, A1, A2, A3, A4) / 60, main = "", 
     prob = TRUE, xlab = "Stop 4 ETA (min)")
```


# <small>Part Four</small><br>Arrival time distrutions<span style="margin:0.5em;display:block">$\downarrow$</span>ETAs

----
<h2>Arrival time distribution</h2>

- we have a distribution <div style='margin-bottom: 0.5em'></div>
\[
p(A_j | X_k, \Theta_c)
\]
<div style='margin-bottom: 0.5em'></div>
- need to summarize it for the general public


----
<h2>Point estimates</h2>

- expected
- easy to communicate 
- infrastrature exists (real-time boards, etc)


----
<h2>Point estimates ii</h2>

- assumes ETA is exact (it's not)
- underestimate = frustration, hard to plan journey
- overestimate = shorter wait OR miss bus entirely

```{r,fig.height=2.5,echo=F}
par(mar = c(4.1, 4.1, 1.1, 2.1))
hist(A3/60, 40, main = "", xlim = c(3, 6), xaxp = c(3, 6, 3),
     prob = TRUE, xlab = "Stop 3 ETA (min)")
```

- mean? median? some quantile?
- minimise $p(A_j \notin [\hat A_j, \hat A_j+1)), A_j \in 0, 1, 2, \ldots$
- ... stronger penalty on overestimation?

----
<h3>Point estimates iii</h3>

- desirable that $A_j$ decreases with time
- Kalman filter on arrival times? at least for > 10 mins


----
<h3>Prediction intervals</h3>

- unfamiliar to the general public
- allows uncertainty to be expressed
    - at least $\ell_j$ mins away, could be up to $u_j$ mins
- what values?
    - quantiles of predictive distribution?
    - min $p(A_j \notin [\ell_j, u_j])$ constrained by $(u_j - \ell_j)^2$


----

```{r,echo=F,fig.height=5}
N <- 1e5
A <- rlnorm(N, 6.5, 0.1)
par(mfcol = 2:1, mar = c(4.1, 4.1, 2.1, 2.1))
eta <- table(floor(A/60))
hist(A/60, 40, main = "", freq = F, xlab = "ETA (min)", 
    xlim = range(A/60), xaxp = c(8, 16, 8))
plot(names(eta), cumsum(eta / N), 
     type = "s", xlab="ETA (min)", ylab="P(A < ETA)",
     xaxp = c(8, 16, 8),
     xlim = range(A/60), ylim = 0:1, yaxs = "i")

etapr <- cumsum(eta / sum(eta)) * 100
etapr <- round(etapr, ifelse(etapr < 1 | etapr > 99, 3, 1))
knitr::kable(
    t(etapr),
    caption = "Probability (%) bus arrives within x mins"
)
```


----

```{r,echo=F}
A <- rlnorm(N, 8, 0.15)
par(mfcol = 2:1, mar = c(4.1, 4.1, 2.1, 2.1))
eta <- table(round(A/60))
hist(A/60, 60, main = "", freq = F, xlab = "ETA (min)", 
     xlim = range(A/60), xaxp = c(30, 90, 6))
plot(names(eta), cumsum(eta / N), 
     type = "s", xlab="ETA (min)", ylab="P(A < ETA)",
     xlim = range(A/60), ylim = 0:1, yaxs = "i",
     xaxp = c(30, 90, 6))
```




# fin.
